use alloy::rpc::types::TransactionRequest;
use async_trait::async_trait;
use eyre::Result;
use std::pin::Pin;
use tokio_stream::Stream;
use tokio_stream::StreamExt;

use crate::collectors::block_collector::NewBlock;
use crate::executors::mempool_executor::SubmitTxToMempool;

/// A stream of events emitted by a [Collector](Collector).
/// This type alias represents a pinned, boxed stream that can send events across thread boundaries.
pub type CollectorStream<'a, E> = Pin<Box<dyn Stream<Item = E> + Send + 'a>>;

/// Collector trait defines a source of events in the Artemis framework.
/// Collectors are responsible for gathering events from external sources such as:
/// - Blockchain events (new blocks, pending transactions)
/// - DEX events (new orders, price updates)
/// - Market data feeds
/// - Custom event sources
#[async_trait]
pub trait Collector<E>: Send + Sync {
    /// Returns the core event stream for the collector.
    /// This stream will emit events of type E that can be processed by strategies.
    async fn get_event_stream(&self) -> Result<CollectorStream<'_, E>>;
}

/// Strategy trait defines the core logic for identifying and acting on MEV opportunities.
/// Strategies receive events from collectors, analyze them for opportunities, and generate
/// appropriate actions when opportunities are found.
///
/// Type Parameters:
/// - E: The type of events this strategy can process
/// - A: The type of actions this strategy can generate
#[async_trait]
pub trait Strategy<E, A>: Send + Sync {
    /// Initializes the strategy's state.
    /// This is called once when the strategy starts and can be used to:
    /// - Load initial blockchain state
    /// - Set up connections to required services
    /// - Initialize internal data structures
    async fn init_state(&mut self) -> Result<()>;

    /// Synchronizes the strategy's state with current conditions.
    /// This can be called periodically to ensure the strategy's state
    /// remains consistent with external conditions.
    async fn sync_state(&mut self) -> Result<()>;

    /// Processes an incoming event and generates appropriate actions.
    /// This is the core logic of the strategy where MEV opportunities
    /// are identified and acted upon.
    ///
    /// Returns a vector of actions to be executed. An empty vector
    /// indicates no action needs to be taken for this event.
    async fn process_event(&mut self, event: E) -> Vec<A>;
}

/// Executor trait defines how actions generated by strategies are carried out.
/// Executors are responsible for interacting with external systems to implement
/// the actions decided by strategies.
#[async_trait]
pub trait Executor<A>: Send + Sync {
    /// Executes a single action.
    /// This could involve:
    /// - Submitting transactions to the mempool
    /// - Sending transactions to Flashbots
    /// - Placing orders on DEXes
    /// - Any other action required by the strategy
    async fn execute(&self, action: A) -> Result<()>;
}

/// CollectorMap is a wrapper around a [Collector](Collector) that maps outgoing
/// events to a different type. This allows for composition and transformation
/// of event streams.
///
/// Type Parameters:
/// - E: The original event type
/// - F: The function type that maps from E to another type
pub struct CollectorMap<E, F> {
    collector: Box<dyn Collector<E>>,
    f: F,
}

impl<E, F> CollectorMap<E, F> {
    /// Creates a new CollectorMap with the given collector and mapping function.
    pub fn new(collector: Box<dyn Collector<E>>, f: F) -> Self {
        Self { collector, f }
    }
}

#[async_trait]
impl<E1, E2, F> Collector<E2> for CollectorMap<E1, F>
where
    E1: Send + Sync + 'static,
    E2: Send + Sync + 'static,
    F: Fn(E1) -> E2 + Send + Sync + Clone + 'static,
{
    async fn get_event_stream(&self) -> Result<CollectorStream<'_, E2>> {
        let stream = self.collector.get_event_stream().await?;
        let f = self.f.clone();
        let stream = stream.map(f);
        Ok(Box::pin(stream))
    }
}

/// ExecutorMap is a wrapper around an [Executor](Executor) that maps incoming
/// actions to a different type. This allows for composition and transformation
/// of action handling.
///
/// Type Parameters:
/// - A: The original action type
/// - F: The function type that maps to another action type
pub struct ExecutorMap<A, F> {
    executor: Box<dyn Executor<A>>,
    f: F,
}

impl<A, F> ExecutorMap<A, F> {
    /// Creates a new ExecutorMap with the given executor and mapping function.
    pub fn new(executor: Box<dyn Executor<A>>, f: F) -> Self {
        Self { executor, f }
    }
}

#[async_trait]
impl<A1, A2, F> Executor<A1> for ExecutorMap<A2, F>
where
    A1: Send + Sync + 'static,
    A2: Send + Sync + 'static,
    F: Fn(A1) -> Option<A2> + Send + Sync + Clone + 'static,
{
    async fn execute(&self, action: A1) -> Result<()> {
        let action = (self.f)(action);
        match action {
            Some(action) => self.executor.execute(action).await,
            None => Ok(()),
        }
    }
}

/// Convenience enum containing all the events that can be emitted by collectors.
/// This enum provides a unified type for all possible events in the system.
#[derive(Debug, Clone)]
pub enum Events {
    /// A new block has been mined
    NewBlock(NewBlock),
    /// A new transaction has been submitted to the mempool
    Transaction(TransactionRequest),
}

/// Convenience enum containing all the actions that can be executed by executors.
/// This enum provides a unified type for all possible actions in the system.
#[derive(Debug, Clone)]
pub enum Actions {
    /// Submit a transaction to the public mempool
    SubmitTxToMempool(SubmitTxToMempool),
}
